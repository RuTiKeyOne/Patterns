using FactoryMethod.Classes.CocreteCreators;
using FactoryMethod.Classes.CocreteTransports;
using System;

namespace FactoryMethod
{
    public enum TypesTransport
    {
        Air, 
        RailWay,
        Nautical,
        Road
    }
    class Program
    {
        static void Main(string[] args)
        {
            Cargo Cargo = new(); //Создаем объект бизнес логики
            Cargo.Shipping(new CreatorAirTransport()); //Создаем объект воздушного транспорта

            Cargo.Shipping(new CreatorNauticalTransport()); //Создаем объект морского транспорта

            Cargo.Shipping(new CreatorRailWayTransport()); //Создаем объект железнодорожного транспорта

            Cargo.Shipping(new CreatorRoadTransport()); //Создаем объект автомобильного транспорта



        }

        /*
         Паттерн фабричный метод
         
         Зачем нужен данный паттерн:
         1.Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код
         2.Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки
         3.Когда вы хотите экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых

         Данный паттерн позволяет объявлять общий интерфейс для создания объектов в суперклассе, позволяя подклассам
         изменять тип создаваемого объекта 

         А теперь конкретнее 

         Общий интерфейс - это ITransport, от общий для всех видов транспорта
         У нас есть конкретные виды транспорта (AirTransport, RoadTransport, RailWayTransport, NauticalTransport)
         Объекты я создаю в суперклассе (Creator) он абстрактный
         И в подклассах Creator мы можем менять тип создаемого объекта 
         (CreatorAirTransport, CreatorRoadTransport, CreatorRailWayTransport, CreatorNauticalTransport) 


         Как реализовать данный паттерн:
         1.Создадим общий интерфейс для всех видов "продуктов", ну а в нашем случае транспорта
         2.Создадим абстрактный классс который мы будем переопределять в подклассах
         В данном классе будет метод для создания абстрактного продукта(именно его мы и будем переопределять)
         3.Создадим конкретные виды "продуктов" в нашем случае видом транспорта
         4.Создадим конкретных создателей, каждого для определенного вида
         5.В бизнес логике создадим метод который будет принимать абстрактный Creator и будем передавать 
         в него конкретных создателей
         
         
         Плюсы:
         +Избавляет класс от привязки к конкретным классам продуктов
         +Выделяет код производства продуктов в одно место, упрощая поддержку кода
         +Упрощает добавление новых продуктов в программу
         +Реализует принцип открытости/закрытости

         Минусы:
         -Может привести к созданию большой иерархии классов
 
         */
    }
}
