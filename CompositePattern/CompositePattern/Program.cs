using System;
using CompositePattern.Composites;
using CompositePattern.Leafs;

namespace CompositePattern
{
    class Program
    {
        static void Main(string[] args)
        {
            Client Client = new(); //Создаем объект клиента

            PlatoonCommander PlatCommander = new(); //Создаем объект командира взвода
            PlatCommander.Add(new Soldier()); //Добавляем солдата
            PlatCommander.Add(new Soldier()); //Добавляем солдата
            PlatCommander.Add(new Soldier()); //Добавляем солдата


            RegimentCommander RegCommander = new(); //Создаем объект командира полка
            RegCommander.Add(PlatCommander);        //Добавляем командира взвода

            CommanderInChief CommanderInChief = new(); //Создаем объект главнокомандующего
            CommanderInChief.Add(RegCommander); //Добавляем командира полка

            Client.ClientCode(CommanderInChief); //Передаем главнокомандующего
            Console.WriteLine("------------------------");
            Client.ClientCode(RegCommander); //Передаем командира полка
            Console.WriteLine("------------------------");
            Client.ClientCode(PlatCommander); //Передаем командира взвода
            Console.WriteLine("------------------------");
            Client.ClientCode(new Soldier()); //Передаем солдата
        }


        /*
         Паттерн компоновщик 
         
         Паттерн компоновщик позволяет сгруппировать множество объектов в дреевидную структуру, а после работать с 
         ней так, как будто это единый объект при этом не используя наследования, а используя ассоциацию.

         Когда следует использовать данный паттерн:
         1.Когда нужно предоставить объекты в треевидной структуре
         2.Когда клиенты должны одинаково работать как с простыми так и составными объектами

         Подробнее о паттерне компоновщик 
         
         *Это для меня в будущем
         
          Компоновщик позволяет выделить составной объект:
                                Кратко о составном объекте:
                                         1.Составной объект может иметь вложенные компоненты
                                         2.Составной объект обычно делегирует часть работы простым объектам и просто
                                         суммирует результат
                                         3.Составной объект содержит в себе вложенные объекты
          Компоновщик создает простой объект:
                                Кратко о простом объекте:
                                         1.Простой объект не может содержать вложенные объекты
                                         2.Обычно в простых объектах выполняется вся работа

          Шаги реализации:
          1.Подумайте можно ли из множества объектов составить дреевидную структуру
                                *Разбейте объекты на простые и составные
                                *Составные объекты могут содержать ссылки как на другие составные, так и
                                 на простые объекты
          2.Выделите класс компонента, который будет общим для всех остальных элементов структуры
                                *Компонент будет объединять в себе простые и составные объекты
          3.Создайте простые классы (классы которые не будут иметь ответвления, в нашем случае это класс Soldier)
          4.Создайте составные классы(классы, которые будут содержат в себе вложенные объекты, у нас это 
          CommanderInChief, PlatoonCommander, RegimentCommander)
                                *В составном классе должно быть 
                                             1.Список вложенных классов(List)
                                             2.Методы добавления и удаления вложенных классов
          5.Реализуйте в составном классе методы интерфейса компонентов, помня о том, что контейнеры должны делегировать основную 
          работу своим дочерним компонентам.

          Плюсы:
          + Облегчает добавление составных классов
          + Упрощает архитектуру клиента при работе со деревом 
            
          Минусы:
          - Создаёт слишком общий дизайн классов 
          - Может сильно усложнить архитектуру проекта
          
          Вывод: Использовать когда необходимо из объектов составить дреевидную структуру и при этом работать с этими
          объектами как с одним.
   
         */
    }
}
