using Strategy.Classes;
using Strategy.Clients;

namespace Strategy
{
    class Program
    {

        static void Main(string[] args)
        {
            Human Andrew = new Human(new Cat("Рыжик"));

            Andrew.PlayWithTheAnimal();

            
        }

        /*
         Паттерны нужны для решения конекретной проблемы проектирования, 
         их не всегда уместно использовать, особенно я говорю о простых приложениях.

         Паттерн "Стратегия"

         Создает и инкапсулирует поведение, которое с легкостью можно подменить или добавить
         
         Поведение - это в конкретном случае классы Cat, Dog, Cow
         *Мы с легкостью можем создать класс нового животного наследуемого от IHomeAnimal
         
         В классе Human мы создаем поле которое принимает IHomeAnimal, в main мы передаем наследников при этом происходит Upcast,
         в методе PlayWithTheAnimal мы можем выполнять какую-нибудь работу

         *Паттерн стратегия распростронен по всему net
         
         Данный паттерн необходимо использовать для моделирования множества операциий, которые с легкостью можно подменить

        *Мы используем полиморфизм и наследование это очень гибко, но это усложняет код
        
        Плюсы 
        +Возможность замены на лету
        +Инкапсуляция кода
        +Делегирование
        +Принцип открытости/закрытости

        Минусы
        -Усложняет архитектуру
        
         */
    }
}
