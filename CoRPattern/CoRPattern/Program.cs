using System;
using CoRPattern.Classes;
using CoRPattern.Classes.DevelopmentStates;

namespace CoRPattern
{
    public enum LevelProblem
    {
        NoProblem,
        Low,
        Medium,
        Hight
    }
    class Program
    {
        static void Main(string[] args)
        {
            NoProblem No = new(); //Создаем отдельные элементы цепочки
            SmallProblem Small = new();//Создаем отдельные элементы цепочки
            HudeProblem Hude = new();//Создаем отдельные элементы цепочки
            No.SetNext(Small).SetNext(Hude); // Соединяем цепочку

            Project MobileApplication = new();

            MobileApplication.AddDevelop(new Developer(LevelProblem.Hight));

            MobileApplication.AddDevelop(new Developer(LevelProblem.Low));

            MobileApplication.AddDevelop(new Developer(LevelProblem.NoProblem));

            MobileApplication.Debug(No); //Вызываем локигу прохода по цепочке 
            

        }

        /*
         Паттерн цепочка обязанностей 

         Паттерн который создает классы который определяет единую цепочку 
         и каждая цепочка определяет может ли она обработать запрос


         Для чего нужен данный паттерн :
         1.Если необходимо чтобы запросы обрабатывались один за другим
         2.Для динамического добавления запроса
         3.Когда программа должна обрабатывать разнообразные запросы несколькими способами, 
         но заранее неизвестно, какие конкретно запросы будут приходить и какие обработчики 
         для них понадобятся
         

         Тоесть у нас есть определенный запрос и есть ряд классов(единиц цепочки). 
         Данные классы определяют могут ли они обработать запрос самостоятельно или
         необходимо вызвать следущую цепочку и передать запрос ей 

         Как реализовать данный паттерн : 
         1. Необходимо подумать нужна ли вам цепочка классов (данный паттерн)
         2. Если нужна то
                   : a) Создадим интерфейс для работы со всеми элементами цепи.
                        Он будет содержать в себе методы установки значения для следующей цепи.
                        Так же он будет содержать в себе метод для обработки запроса. 
                     б) Создадим абстрактный класс.
                       Он нужен для того чтобы хранить в себе ссылку на новый элемент цепи.
                       Абстрактный класс сождержит в себе логику добавления нового элемента цепи. 
                     в) Создадим конкретные цепи(NoProblem, SmallProblem, HudeProblem) и реализуем логику
                        обработки запроса. Если мы не можем обработать запрос то передаём его следущей цепи. 
         3. Используем цепочку обязанностей





        Плюсы +
        + Уменьшает зависимость между клиентом и обработчиками.
        + Реализует принцип единственной обязанности.
        + Реализует принцип открытости/закрытости.

        Минусы -
        - Запрос может быть не обработан
         
         */


    }
}
