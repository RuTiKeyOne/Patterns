using ProxyPattern.Classes;
using System;

namespace ProxyPattern
{
    class Program
    {
        static void Main(string[] args)
        {
            Customer Customer = new(); //Создаем объект клиента
            Customer.MakeOrder(new Proxy(10000), 5000); //Передаем заместителя и проверяем результат
            Console.WriteLine(new string('-', 30));
            Customer.MakeOrder(new Cash(3000), 2000); //Передаем сервисный объект и проверяем результат
            Console.WriteLine(new string('-', 30));
            Customer.MakeOrder(new Cash(1000), 2000); //Передаем сервисный объект и проверяем результат
        }

        /*
         Паттерн заместитель

         Паттерн заместитель позволяет подставлять вместо реальных объектов объекты-заместители.
         Объекты-заместители перехватывают вызовы к реалиному объекту и позволяют сделать что-то до вызова 
         логики реального объекта и сделать что-то после.

         Сразу опишу структуру проекта:
         1. IPayment - это общий интерфейс для реального объекта и его заместителя
         2. Cash - это реальный объект который содержит в себе какую-то логику
         3. Proxy - это заместитель объекта Cash, он определяет логику вызова метода Cash и что нужно сделать до и 
         сделать после
         4. Customer - это класс бизнес логики, он определяет метод в который можно подставить как реальный объект так 
         и его заместителя
         
         Когда следует использовать данный паттерн:
         1. Если необходимо использовать ленивую инициализацию. Когда у вас есть тяжёлый объект, грузящий данные из 
         файловой системы или базы данных
         2.Когда реальный объект(сервис) находиться удаленно. Создаем заместителя и запускаем локально
         3.Для защиты доступа. Если у нас есть разные виды классов, одним мы ходим давать доступ бизнес логику, а другим 
         только заместителя. (Защищающий прокси)
         4.Сохранение истории обращений к сервисному объекту (можно реализовать данную логику через заместителя)
         
         Шаги реализации:
         1.Определите общий интерфейс для класса сервиса и заместителя
         2.Создайте класс заместителя, создайте ссылку на объект
         3.Реализуйте методы заместителя в зависимости от предозначения
         4.Добавите метод в клиенскую логику который будет принимать общий интерфейс
         5.Подумайте о введении фабрики и ленивой инициализации

         Плюсы:
         +Контроль за жизненным циклом служебного объекта 
         +Работает, даже если сервисный объект еще не создан
         +Позволяет контролировать сервисный объект независимо от клиента
         
         Минусы:
         -Усложняет архитектуру программы 
         -Увеличивает время отклика от сервиса
         
         */
    }
}
