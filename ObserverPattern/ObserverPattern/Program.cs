using System;
using ObserverPattern.Interfaces;
using ObserverPattern.Subject;

namespace ObserverPattern
{
    class Program
    {
        static void Main(string[] args)
        {
            //Создаём объекты конкретных наблюдателей
            Customer1 customer1 = new();
            Customer2 customer2 = new();

            //Создаем объект магазина
            Shop shop = new();

            //Добавляем наблюдателей в подписчики
            shop.Attach(customer1);
            shop.Attach(customer2);

            //Завозим хлеб
            shop.GetBread();

            //Можно удалить наблюдателя из подписчиков
            shop.Detach(customer1);

        }


        /*
        Паттерн наблюдатель
         
        Похож на паттерн посредник но необходим немного для другого 

        Паттерн посредник - это связующее звено между классами, то есть есть в одном классе что-то изменилось и необходимо
        уведомить об этом другие классы мы используем паттерн посредник
        
        Паттерн наблюдатель необходим есть у нас есть важный класс за состоянием которого наблюдают другие классы
        Например как в приведённом выше примере магазин-покупатель, если в магазин завезли хлеб, то покупатель узнаёт об этом
        и уже сам решает что с этим делать (Очень нравиться данный паттерн)

        Что необходимо для того чтобы реализовать данный паттерн: 
        1. Необходимо создать интерфейсы для издателя(ISubject) и наблюдателя(IObserver)
        Так же необходимо создать методы для подписки, отписки и уведомления и принятия уведомления
        2. Создаём класс издателя, создаём список наблюдателей, реализуем класс ISubject
        3. Создаем конкретный наблюдателей и реализуем интерфейс IObserver и логику 
        4. Создаем объекты наблюдателей, издателя, добавляем их в List и завозим хлеб
         
        Плюсы +
        + Издатели не зависят от конкретных классов подписчиков и наоборот.
        + Вы можете подписывать и отписывать получателей на лету.
        + Реализует принцип открытости/закрытости.
         
        Минусы -
        -Подписчики оповещаются случайно

        Выводы: 
        1. Паттерн необходим если необходимо прореагировать на изменения в конкретном классе, при этом знаю какие 
        классы должны прореагировать.
        2. Когда одни объекты должны менять поведение определенным образом при изменение в другом объекте 
         */
    }
}
